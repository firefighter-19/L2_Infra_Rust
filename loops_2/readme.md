# Функционал `loops_2`

## Описание проекта

Этот проект реализует алгоритм **бинарного поиска** (binary search) для отсортированных массивов. Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве, который работает за время O(log n).

### Основные возможности

- Поиск элемента в отсортированном массиве целых чисел
- Обработка граничных случаев:
  - Пустой массив
  - Массив с одним элементом
  - Элемент не найден
  - Отрицательные числа
- Возвращает `Option<usize>`: индекс элемента или `None`, если элемент не найден
- Полное покрытие тестами

### Реализация

Алгоритм использует цикл `while` для итеративного поиска:
- Делит массив пополам на каждой итерации
- Сравнивает средний элемент с искомым значением
- Сужает область поиска в зависимости от результата сравнения
- Использует `usize::midpoint()` для безопасного вычисления среднего индекса
- Обрабатывает переполнение при вычитании через `checked_sub()`

### Как запустить

```bash
cargo run
```

### Тестирование

```bash
cargo test
```

---

## Циклы в Rust

Rust предоставляет несколько видов циклов для итеративного выполнения кода. Каждый тип цикла имеет свои особенности и области применения.

### 1. Цикл `loop` (бесконечный цикл)

Цикл `loop` выполняет код бесконечно, пока не будет явно прерван с помощью `break` или `return`.

```rust
// Базовый пример
let mut counter = 0;
loop {
    counter += 1;
    if counter >= 5 {
        break; // Выход из цикла
    }
    println!("Счетчик: {}", counter);
}

// Возврат значения из цикла
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2; // Возвращает значение
    }
};
println!("Результат: {}", result); // 20

// Вложенные циклы с метками
'outer: loop {
    'inner: loop {
        break 'outer; // Выход из внешнего цикла
    }
}
```

### 2. Цикл `while` (цикл с условием)

Цикл `while` выполняет код, пока условие истинно.

```rust
// Базовый пример
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number -= 1;
}
println!("Старт!");

// Использование в алгоритмах (как в бинарном поиске)
let mut left = 0;
let mut right = 10;
while left <= right {
    let mid = (left + right) / 2;
    // ... логика поиска
    if some_condition {
        right = mid - 1;
    } else {
        left = mid + 1;
    }
}
```

### 3. Цикл `for` (итерация по коллекциям)

Цикл `for` используется для итерации по элементам коллекции или диапазону.

#### Итерация по диапазону

```rust
// Диапазон чисел (0..5 не включает 5)
for i in 0..5 {
    println!("{}", i); // 0, 1, 2, 3, 4
}

// Диапазон с включением конечного значения
for i in 0..=5 {
    println!("{}", i); // 0, 1, 2, 3, 4, 5
}

// Обратный порядок
for i in (0..5).rev() {
    println!("{}", i); // 4, 3, 2, 1, 0
}

// С шагом
for i in (0..10).step_by(2) {
    println!("{}", i); // 0, 2, 4, 6, 8
}
```

#### Итерация по массивам и векторам

```rust
// Итерация по массиву (получение значений)
let arr = [10, 20, 30, 40, 50];
for element in arr {
    println!("{}", element);
}

// Итерация по массиву (получение ссылок)
let arr = [10, 20, 30];
for element in &arr {
    println!("{}", element);
}

// Итерация с индексами
for (index, value) in arr.iter().enumerate() {
    println!("Индекс: {}, Значение: {}", index, value);
}
```

#### Итерация по вектору

```rust
let vec = vec![1, 2, 3, 4, 5];

// Итерация по значениям (вектор перемещается)
for value in vec {
    println!("{}", value);
}
// vec больше нельзя использовать здесь

// Итерация по ссылкам (вектор остается доступным)
let vec = vec![1, 2, 3, 4, 5];
for value in &vec {
    println!("{}", value);
}
// vec все еще доступен

// Итерация с изменением
let mut vec = vec![1, 2, 3, 4, 5];
for value in &mut vec {
    *value *= 2; // Удваиваем каждое значение
}
println!("{:?}", vec); // [2, 4, 6, 8, 10]
```

#### Итерация по строкам

```rust
// Итерация по символам строки
let s = "Привет";
for char in s.chars() {
    println!("{}", char);
}

// Итерация по байтам
for byte in s.bytes() {
    println!("{}", byte);
}
```

#### Итерация по HashMap

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert("Alice", 10);
scores.insert("Bob", 20);

// Итерация по парам ключ-значение
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

### 4. Управление циклами

#### `break` - выход из цикла

```rust
for i in 0..10 {
    if i == 5 {
        break; // Выход из цикла
    }
    println!("{}", i); // 0, 1, 2, 3, 4
}
```

#### `continue` - переход к следующей итерации

```rust
for i in 0..10 {
    if i % 2 == 0 {
        continue; // Пропустить четные числа
    }
    println!("{}", i); // 1, 3, 5, 7, 9
}
```

#### Метки для вложенных циклов

```rust
'outer: for x in 0..5 {
    'inner: for y in 0..5 {
        if x * y > 10 {
            break 'outer; // Выход из внешнего цикла
        }
        if y > 2 {
            continue 'inner; // Переход к следующей итерации внутреннего цикла
        }
        println!("x: {}, y: {}", x, y);
    }
}
```

### Сравнение циклов

| Цикл | Когда использовать |
|------|-------------------|
| `loop` | Когда нужен бесконечный цикл или возврат значения из цикла |
| `while` | Когда условие проверяется перед каждой итерацией |
| `for` | Когда нужно итерироваться по коллекции или диапазону |

---

## Ownership (Владение) и Borrowing (Заимствование)

Одной из ключевых особенностей Rust является система владения (ownership), которая обеспечивает безопасность памяти без сборщика мусора. Понимание ownership и borrowing критически важно для эффективной работы с Rust.

### Ownership (Владение)

**Владение** - это набор правил, которые определяют, как Rust управляет памятью:

1. Каждое значение в Rust имеет переменную, которая называется его **владельцем** (owner)
2. В один момент времени может быть только **один владелец**
3. Когда владелец выходит из области видимости, значение **удаляется** (drop)

#### Примеры владения

```rust
// Переменная s владеет строкой
let s = String::from("hello");
// s - владелец строки "hello"

// Когда s выходит из области видимости, память автоматически освобождается
```

#### Перемещение (Move)

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 перемещается в s2

// println!("{}", s1); // ОШИБКА! s1 больше не владеет значением
println!("{}", s2); // OK, s2 теперь владелец

// Для простых типов (копируемых) перемещения не происходит
let x = 5;
let y = x; // Копирование, а не перемещение
println!("{}", x); // OK, x все еще доступен
```

#### Копируемые типы (Copy types)

Некоторые типы автоматически копируются вместо перемещения:

```rust
// Целые числа
let x = 5;
let y = x; // Копирование
println!("{}", x); // OK

// Булевы значения
let b1 = true;
let b2 = b1; // Копирование

// Символы
let c1 = 'a';
let c2 = c1; // Копирование

// Кортежи, если все элементы копируемые
let t1 = (1, 2, 3);
let t2 = t1; // Копирование
println!("{:?}", t1); // OK
```

#### Владение в функциях

```rust
fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string выходит из области видимости и удаляется

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // some_integer выходит из области видимости, но это копируемый тип

let s = String::from("hello");
takes_ownership(s); // s перемещается в функцию
// s больше нельзя использовать здесь

let x = 5;
makes_copy(x); // x копируется в функцию
println!("{}", x); // OK, x все еще доступен
```

#### Возврат владения

```rust
fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string // Владение передается вызывающему коду
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string // Владение возвращается
}

let s1 = gives_ownership();
let s2 = String::from("world");
let s3 = takes_and_gives_back(s2); // s2 перемещается и возвращается как s3
```

### Borrowing (Заимствование)

**Заимствование** позволяет использовать значение без передачи владения. Вместо передачи владения, мы передаем ссылку на значение.

#### Неизменяемые ссылки (`&`)

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
} // s выходит из области видимости, но ничего не удаляется, т.к. это ссылка

let s1 = String::from("hello");
let len = calculate_length(&s1); // Передаем ссылку, а не владение
println!("Длина '{}' равна {}", s1, len); // s1 все еще доступен

// Можно иметь несколько неизменяемых ссылок одновременно
let s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &s;
println!("{}, {}, {}", r1, r2, r3); // OK
```

#### Изменяемые ссылки (`&mut`)

```rust
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}

let mut s = String::from("hello");
change(&mut s); // Передаем изменяемую ссылку
println!("{}", s); // "hello, world"

// Можно иметь только ОДНУ изменяемую ссылку в области видимости
let mut s = String::from("hello");
let r1 = &mut s;
// let r2 = &mut s; // ОШИБКА! Нельзя иметь две изменяемые ссылки

// Нельзя смешивать изменяемые и неизменяемые ссылки
let mut s = String::from("hello");
let r1 = &s; // OK
let r2 = &s; // OK
// let r3 = &mut s; // ОШИБКА! Нельзя иметь изменяемую ссылку, пока есть неизменяемые
```

#### Правила заимствования

1. **В любой момент времени можно иметь либо:**
   - Любое количество неизменяемых ссылок (`&T`)
   - Или ровно одну изменяемую ссылку (`&mut T`)

2. **Ссылки всегда должны быть действительными** (нельзя ссылаться на удаленную память)

```rust
// Пример нарушения правил
let mut s = String::from("hello");
let r1 = &s; // Неизменяемая ссылка
let r2 = &s; // Еще одна неизменяемая ссылка
// let r3 = &mut s; // ОШИБКА! Нельзя создать изменяемую ссылку
println!("{}, {}", r1, r2); // r1 и r2 используются здесь
// Теперь можно создать изменяемую ссылку, т.к. r1 и r2 больше не используются
let r3 = &mut s; // OK
```

#### Срезы (Slices) - особый вид заимствования

```rust
let s = String::from("hello world");
let hello = &s[0..5]; // Срез - это ссылка на часть строки
let world = &s[6..11];

// Срезы массивов
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3]; // [2, 3]
```

### Практические примеры

#### Пример 1: Избежание копирования

```rust
// Без заимствования (неэффективно - копирование)
fn first_word_bad(s: String) -> String {
    // ... создание новой строки
    s // Передача владения обратно
}

// С заимствованием (эффективно)
fn first_word_good(s: &String) -> &str {
    // ... возврат среза
    &s[0..5]
}

let s = String::from("hello world");
let word = first_word_good(&s); // Не передаем владение
println!("{}", s); // s все еще доступен
```

#### Пример 2: Изменение через ссылку

```rust
fn add_one(n: &mut i32) {
    *n += 1; // Разыменование и изменение значения
}

let mut x = 5;
add_one(&mut x);
println!("{}", x); // 6
```

#### Пример 3: Владение в циклах

```rust
// Перемещение владения
let vec = vec![1, 2, 3];
for value in vec {
    println!("{}", value);
}
// vec больше нельзя использовать

// Заимствование
let vec = vec![1, 2, 3];
for value in &vec {
    println!("{}", value);
}
// vec все еще доступен
println!("{:?}", vec); // OK

// Изменение через изменяемую ссылку
let mut vec = vec![1, 2, 3];
for value in &mut vec {
    *value *= 2;
}
println!("{:?}", vec); // [2, 4, 6]
```

### Владение в структурах

```rust
struct Person {
    name: String, // Владение строкой
    age: u32,
}

let person = Person {
    name: String::from("Alice"),
    age: 30,
};

// При перемещении структуры, все поля перемещаются
let person2 = person;
// person.name больше нельзя использовать
```

### Владение и методы

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Заимствование (неизменяемое)
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // Заимствование (изменяемое)
    fn double_size(&mut self) {
        self.width *= 2;
        self.height *= 2;
    }

    // Владение (редко используется)
    fn consume(self) -> u32 {
        self.width * self.height
    }
}

let mut rect = Rectangle { width: 10, height: 20 };
let area = rect.area(); // Неизменяемое заимствование
rect.double_size(); // Изменяемое заимствование
// rect.consume(); // Если вызвать это, rect больше нельзя использовать
```

### Резюме

- **Владение**: Каждое значение имеет одного владельца. Когда владелец выходит из области видимости, значение удаляется.
- **Заимствование**: Использование ссылок (`&` и `&mut`) для доступа к значениям без передачи владения.
- **Правила**: Можно иметь любое количество неизменяемых ссылок ИЛИ одну изменяемую ссылку.
- **Преимущества**: Безопасность памяти на этапе компиляции без сборщика мусора.

Понимание этих концепций критически важно для написания эффективного и безопасного кода на Rust!

